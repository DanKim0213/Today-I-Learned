# Optimization

Table of Content
- Recursive Algorithm
- Divide and Conquer
- Dynamic Programming

## Recursive Algorithm

[하노이의 탑](B11729.md)

## Divide and Conquer

[피보나치 수](B2747.md)

## DP

### Basic
[쉬운 계단 수](B10844.md), [이동하기](B11048.md), [카드 구매하기](B11052.md), [가장 긴 증가하는 부분 수열](B11053.md), [오르막 수](B11057.md), [2xn 타일링 2](B11727.md), [동물원](B1309.md), [1로 만들기](B1463.md), [내리막 길](B1520.md), [제곱수의 합](B1699.md), [점프](B1890.md), [연속합](B1912.md), [타일 채우기](B2133.md), [이친수](B2193.md), [동전 1](B2293.md)

### Advanced

[동전 2](B2294.md), [DDR](B2342.md)

## Q. "Divide and Conquer" vs "Decrease and Conquer" 

According to [Wikipedia](https://en.wikipedia.org/wiki/Divide-and-conquer_algorithm):

> The divide-and-conquer paradigm is often used to find an optimal solution of a problem. Its basic idea is to decompose a given problem into two or more similar, but simpler, subproblems, to solve them in turn, and to compose their solutions to solve the given problem.

> The name "divide and conquer" is sometimes applied to algorithms that reduce each problem to only one sub-problem, such as the binary search algorithm for finding a record in a sorted list.

> Under this broad definition, however, every algorithm that uses recursion or loops could be regarded as a "divide-and-conquer algorithm". 

> Therefore, some authors consider that the name "divide and conquer" should be used only when each problem may generate two or more subproblems.[3] The name decrease and conquer has been proposed instead for the single-subproblem class.
