# 친구 네트워크

[link](https://www.acmicpc.net/problem/4195)

## Could you solve Baekjoon 4195?

Certainly! The Baekjoon 4195 problem is known as "친구 네트워크" (Friend Network). Here's the Python code to solve it:

```python
def find_parent(parent, x):
    if parent[x] != x:
        parent[x] = find_parent(parent, parent[x])
    return parent[x]


def union(parent, count, x, y):
    x = find_parent(parent, x)
    y = find_parent(parent, y)

    if x != y:
        parent[y] = x
        count[x] += count[y]


# Read input values
t = int(input())

for _ in range(t):
    f = int(input())
    friend_map = {}
    parent = {}
    count = {}

    for _ in range(f):
        a, b = input().split()

        if a not in friend_map:
            friend_map[a] = len(friend_map)
            parent[friend_map[a]] = friend_map[a]
            count[friend_map[a]] = 1

        if b not in friend_map:
            friend_map[b] = len(friend_map)
            parent[friend_map[b]] = friend_map[b]
            count[friend_map[b]] = 1

        union(parent, count, friend_map[a], friend_map[b])
        print(count[find_parent(parent, friend_map[a])])
```

In this solution, we use the union-find algorithm to track and count the number of friends in each network.

First, we define two helper functions: `find_parent` and `union`. The `find_parent` function recursively finds the parent of a set by path compression, and the `union` function performs the union of two sets while updating the count of friends.

We read the input value `t` representing the number of test cases. For each test case, we read the value `f` representing the number of friend relationships.

**We maintain a `friend_map` dictionary to map each friend's name to a unique ID.** We also have `parent` and `count` dictionaries to track the parent of each friend's set and the count of friends in each set, respectively.

For each friend relationship, we check if the friend is already in the `friend_map`. If not, we assign a unique ID to the friend and initialize its parent and count. Then, we perform the union operation using the `union` function, and print the count of friends in the parent's set.

The code assumes the input is read from standard input. For each test case, the first line contains the value of `f`. The following `f` lines represent the friend relationships, where each line contains two friend names separated by a space. You may need to modify the code if your input format differs.

## Why do you use Dictionary to `friend_map` rather than `Set`?

It is because I map str to int by `len(friend_map)` to generate a unique ID. Note that I check `a` or `b` if not in `friend_map`. It means sometimes `a` or `b` is in `friend_map` and then we can figure out the unique id which has been generated by `len(friend_map)`. 

To get to the bottom line, if we use `Set`, we don't know the unique ID we have generated. Look at the below code:

```python
f = int(input())
friends: set[str] = set()
parents: list[int] = []
counts: list[int] = []

for _ in range(f):
    a, b = input().split()

    if a not in friends:
        idx_a = len(friends)
        friends.add(a)
        parents.append(idx_a)
        counts.append(1)

    if b not in friends:
        idx_b = len(friends)
        friends.add(b)
        parents.append(idx_b)
        counts.append(1)

    # FIXME: idx_a, idx_b could be undefined
    union(parents, idx_a, idx_b, counts)     
    print(counts[find_parent(parents, idx_a)])

```
